<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">Hexo</a>
  </h1>
  <p class="site-description"></p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>

    <main id="main" class="site-main posts-loop" role="main">
      
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-29-Article009.html"><span>博客改用hexo</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-29-Article009.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-29T06:12:05.000Z">
          2016-06-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>启用jekyll，使用hexo搭建博客</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-18-Article008.html"><span>前端性能指南</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-18-Article008.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-17T18:18:06.000Z">
          2016-06-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>要怎样做出速度很快的网站，给用户一个优秀的体验呢？</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1-避免-内联式-嵌入式-代码"><a href="#1-避免-内联式-嵌入式-代码" class="headerlink" title="1. 避免 内联式/嵌入式 代码"></a>1. 避免 内联式/嵌入式 代码</h3><p>你可以通过三种方式在HTML页面中引入CSS或Javascript代码:</p>
<ol>
<li><strong>内联式</strong>: 在HTML标签的<code>style</code>属性中定义样式，在<code>onclick</code>这样的属性中定义Javascript代码;</li>
<li><strong>嵌入式</strong>: 在页面中使用<code>&lt;style&gt;</code>标签定义样式，使用<code>&lt;script&gt;</code>标签定义Javascript代码;</li>
<li><strong>引用外部文件</strong>: 在<code>&lt;style&gt;</code>标签中定义<code>href</code>属性引用CSS文件，在<code>&lt;script&gt;</code>标签中定义<code>src</code>属性引入Javascript文件.</li>
</ol>
<p>尽管前两种方式减少了HTTP请求数，可是实际上却增加了HTML文档的体积。不过，当你的页面中的CSS或者Javascript代码足够少，反而是开启一个HTTP请求的花费要更大时，采用这两种方式却是最有用的。因此，你需要测试评估这种方式是否真的提升了速度。同时也要考虑到你的页面的目标和它的受众：如果你期望人们只会访问它一次，例如对一些临时活动来说，你决不会期望有回访客出现，那么使用内联式/嵌入式代码能够帮助减少HTTP请求数。</p>
<blockquote>
<p>尽量避免在你的HTML中手工编写CSS/JS（首选的方法是通过工具实现这个过程的自动化）。</p>
</blockquote>
<p>第三种方式不仅使你的代码更有序，而且使得浏览器能够缓存它。这种方式在大多数的情况下都是首选，特别是一些大文件和多页面的情况。</p>
<h3 id="2-样式在上，脚本在下"><a href="#2-样式在上，脚本在下" class="headerlink" title="2. 样式在上，脚本在下"></a>2. 样式在上，脚本在下</h3><p>当我们把样式放在<code>&lt;head&gt;</code>标签中时，浏览器在渲染页面时就能尽早的知道每个标签的样式，我们的用户就会感觉这个页面加载的很快。</p>
<pre><code>&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Browser Diet&lt;/title&gt;

  &lt;!-- CSS --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;all&quot;&gt;
&lt;/head&gt;
</code></pre><p>但是如果我们将样式放在页面的结尾，浏览器在渲染页面时就无法知道每个标签的样式，直到CSS被下载执行后。</p>
<p>另一方面，对于Javascript来说，因为它在执行过程中会阻塞页面的渲染，所以我们要把它放在页面的结尾。</p>
<pre><code>&lt;body&gt;
  &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;

  &lt;!-- JS --&gt;
  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre><h3 id="3-尝试async"><a href="#3-尝试async" class="headerlink" title="3. 尝试async"></a>3. 尝试async</h3><p>为了解释这个属性对于性能优化是多么有用，我们应该先明白，当不使用它时会发生什么。</p>
<pre><code>&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;
</code></pre><p>使用上面这种方式时，页面会在这个脚本文件被完全下载、解析、执行完后才去渲染之后的HTML，在这之前会一直处于阻塞状态。这就意味着会增加你的页面的加载时间。有时这种行为是我们希望的，而大多数时候则不想要。</p>
<pre><code>&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt;
</code></pre><p>使用上面这种方式时，脚本的加载是异步的，不会影响到这之后的页面解析。脚本会在下载完之后立即执行。需要注意的是，如果有多个使用这种方式异步加载的脚本，他们是没有特定的执行顺序的。(defer区别）</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="4-压缩你的样式表"><a href="#4-压缩你的样式表" class="headerlink" title="4. 压缩你的样式表"></a>4. 压缩你的样式表</h3><p>为了保持代码的可读性，最好的方法是在代码中添加注释和使用缩进：</p>
<pre><code>.center {
  width: 960px;
  margin: 0 auto;
}

/* --- Structure --- */

.intro {
  margin: 100px;
  position: relative;
}
</code></pre><p>但是对于浏览器来说，这些都是不重要的。正因为如此，通过自动化工具压缩你的CSS是非常有用的。</p>
<pre><code>.center{width:960px;margin:0 auto}.intro{margin:100px;position:relative}
</code></pre><p>这样做能够减小文件的大小，从而得到更快的下载、解析和执行。</p>
<p>对于使用预处理器例如 Sass, Less, and Stylus, 你可以通过配置缩小编译输出的CSS代码。</p>
<h3 id="5-合并多个css文件"><a href="#5-合并多个css文件" class="headerlink" title="5. 合并多个css文件"></a>5. 合并多个css文件</h3><p>对于样式的组织和维护，另一个好方法是将他们模块化。</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;structure.css&quot; media=&quot;all&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;banner.css&quot; media=&quot;all&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;layout.css&quot; media=&quot;all&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;component.css&quot; media=&quot;all&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;plugin.css&quot; media=&quot;all&quot;&gt;
</code></pre><p>然而，这样每个文件就是一个HTTP请求（我们都知道，浏览器的并行下载数是有限的）。</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot; media=&quot;all&quot;&gt;
</code></pre><p>所以，合并你的CSS文件。文件数量的减少就会带来请求数量的减少和更快的页面加载速度。</p>
<h3 id="6-使用-lt-link-gt-标签而不是-import"><a href="#6-使用-lt-link-gt-标签而不是-import" class="headerlink" title="6. 使用 &lt;link&gt; 标签而不是 @import"></a>6. 使用 <code>&lt;link&gt;</code> 标签而不是 @import</h3><p>有两种方式可以引入一个外部的样式表：通过 <code>&lt;link&gt;</code>标签：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
</code></pre><p>或者通过 <code>@import</code> 指令 (使用在一个外部样式表中或者页面内嵌的 <code>&lt;style&gt;</code> 标签中):</p>
<pre><code>@import url(&apos;style.css&apos;);
</code></pre><p>当你在一个外部样式表中使用第二种方式时，浏览器无法通过并行下载的方式下载这个资源，这样就会导致其他资源的下载被阻塞。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="7-异步加载第三方内容"><a href="#7-异步加载第三方内容" class="headerlink" title="7. 异步加载第三方内容"></a>7. 异步加载第三方内容</h3><p>嵌入一个Youtube视频,问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时down掉或者是被用户或者其公司的防火墙阻止。</p>
<p>为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码 (或者使用 Friendly iFrames).</p>
<pre><code>var script = document.createElement(&apos;script&apos;),
scripts = document.getElementsByTagName(&apos;script&apos;)[0];
script.async = true;
script.src = url;
scripts.parentNode.insertBefore(script, scripts);
</code></pre><p>当你在一个外部样式表中使用第二种方式时，浏览器无法通过并行下载的方式下载这个资源，这样就会导致其他资源的下载被阻塞。</p>
<h3 id="8-缓存数组长度"><a href="#8-缓存数组长度" class="headerlink" title="8. 缓存数组长度"></a>8. 缓存数组长度</h3><p>循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。</p>
<p>要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。</p>
<pre><code>var arr = new Array(1000),
    len, i;

for (i = 0; i &lt; arr.length; i++) {
  // Bad - size needs to be recalculated 1000 times
}

for (i = 0, len = arr.length; i &lt; len; i++) {
  // Good - size is calculated only 1 time and then stored
}
</code></pre><p>虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器</p>
<p>在迭代<code>document.getElementsByTagName(&#39;a&#39;)</code>等类似方法生成的HTML节点数组（NodeList）时，缓存数组长度尤为关键。这些集合通常被认为是“活的”，也就是说，当他们所对应的元素发生变化时，他们会被自动更新。</p>
<pre><code>var links = document.getElementsByTagName(&apos;a&apos;),
    len, i;

for (i = 0; i &lt; links.length; i++) {
  // Bad - each iteration the list of links will be recalculated to see if there was a change
}

for (i = 0, len = links.length; i &lt; len; i++) {
  // Good - the list size is first obtained and stored, then compared each iteration
}

// Terrible: infinite loop example
for (i = 0; i &lt; links.length; i++) {
  document.body.appendChild(document.createElement(&apos;a&apos;));
  // each iteration the list of links increases, never satisfying the termination condition of the loop
  // this would not happen if the size of the list was stored and used as a condition
}
</code></pre><h3 id="9-避免使用document-write"><a href="#9-避免使用document-write" class="headerlink" title="9. 避免使用document.write"></a>9. 避免使用document.write</h3><p>这个（坏）方法已经被开发者抛弃了很多年, 但是在某些情况下仍然是需要的，例如在一些Javascript文件的同步回退中。</p>
<p>举例来说，如果发现Google的CDN没有响应，HTML5 Boilerplate则会通过这个方法来调用本地的jQuery库。</p>
<pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;window.jQuery || document.write(&apos;&lt;script src=&quot;js/vendor/jquery-1.9.0.min.js&quot;&gt;&lt;\/script&gt;&apos;)&lt;/script&gt;
</code></pre><blockquote>
<p>注意: 如果在<code>window.onload</code>事件中或之后执行<code>document.write</code>方法，会将当前页面替换掉。</p>
</blockquote>
<pre><code>&lt;span&gt;foo&lt;/span&gt;
&lt;script&gt;
  window.onload = function() {
    document.write(&apos;&lt;span&gt;bar&lt;/span&gt;&apos;);
  };
&lt;/script&gt;
</code></pre><p>这段代码执行后的结果是页面中只会呈现出bar字符，而不是期望的出现foobar。在<code>window.onload</code>事件之后执行也是同样的结果。</p>
<pre><code>&lt;span&gt;foo&lt;/span&gt;
&lt;script&gt;
  setTimeout(function() {
    document.write(&apos;&lt;span&gt;bar&lt;/span&gt;&apos;);
  }, 1000);
  window.onload = function() {
    // ...
  };
&lt;/script&gt;
</code></pre><p>这段代码执行的结果和上一段代码的结果相同。</p>
<h3 id="10-最小化重排-回流-和重绘"><a href="#10-最小化重排-回流-和重绘" class="headerlink" title="10. 最小化重排(回流)和重绘"></a>10. 最小化重排(回流)和重绘</h3><p>当有任何属性或元素发生改变时，都会引起DOM元素的重排和重绘。</p>
<p>当一个元素的布局不变，外观发生改变时，就会引起重绘。Nicole Sullivan描述这个就像是样式的改变，例如改变<code>background-color</code>。</p>
<p>重排的代价是最高的，当改变一个页面的布局时就会发生重排，例如改变一个元素的宽。</p>
<p>毫无疑问，应当避免过多的重绘和回流，所以，对于下面的代码：</p>
<pre><code>var div = document.getElementById(&quot;to-measure&quot;),
    lis = document.getElementsByTagName(&apos;li&apos;),
    i, len;

for (i = 0, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = div.offsetWidth + &apos;px&apos;;
}
</code></pre><p>应当变为：</p>
<pre><code>var div = document.getElementById(&quot;to-measure&quot;),
    lis = document.getElementsByTagName(&apos;li&apos;),
    widthToSet = div.offsetWidth,
    i, len;

for (i = 0, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = widthToSet + &apos;px&apos;;
}
</code></pre><p>当你设置<code>style.width</code>时，浏览器需要重新计算布局。通常，浏览器暂时是不需要知道改变了元素的样式的，直到它需要更新屏幕时，正因为如此，改变多个元素的样式只会产生一次重排。然而，在第一个例子中，我们每次请求<code>offsetWidth</code>时，都会使浏览器重新计算布局。</p>
<p>如果需要得到页面中的布局数据，那么请参照第二个例子，将这些操作放在任何会改变布局的设置前。</p>
<h3 id="11-避免不必要的dom操作"><a href="#11-避免不必要的dom操作" class="headerlink" title="11. 避免不必要的dom操作"></a>11. 避免不必要的dom操作</h3><p>浏览器遍历DOM元素的代价是昂贵的。虽然Javascript引擎变得越来越强大，越来越快速，但是还是应该最大化的优化查询DOM树的操作。</p>
<pre><code>// really bad!
for (var i = 0; i &lt; 100; i++) {
  document.getElementById(&quot;myList&quot;).innerHTML += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;
}

// much better :)
var myList = &quot;&quot;;

for (var i = 0; i &lt; 100; i++) {
  myList += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;
}

document.getElementById(&quot;myList&quot;).innerHTML = myList;

// much much better :)
var myListHTML = document.getElementById(&quot;myList&quot;).innerHTML;

for (var i = 0; i &lt; 100; i++) {
  myListHTML += &quot;&lt;span&gt;&quot; + i + &quot;&lt;/span&gt;&quot;;
}
</code></pre><h3 id="12-压缩你的脚本"><a href="#12-压缩你的脚本" class="headerlink" title="12. 压缩你的脚本"></a>12. 压缩你的脚本</h3><p>和CSS一样，为了保持代码的可读性，最好的方法是在代码中添加注释和使用缩进：</p>
<pre><code>BrowserDiet.app = function() {

  var foo = true;

  return {
    bar: function() {
      // do something
    }
  };

};
</code></pre><p>但是对于浏览器来说，这些都是不重要的。正因为如此，请记住用自动化工具压缩你的Javascript代码。</p>
<pre><code>BrowserDiet.app=function(){var a=!0;return{bar:function(){}}}
</code></pre><p>这样做能够减小文件的大小，从而得到更快的下载、解析和执行。</p>
<h3 id="13-将多个js文件合并"><a href="#13-将多个js文件合并" class="headerlink" title="13. 将多个js文件合并"></a>13. 将多个js文件合并</h3><p>对于脚本的组织和维护，另一个好方法是将他们模块化。</p>
<pre><code>&lt;script src=&quot;navbar.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;component.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;page.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;framework.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;plugin.js&quot;&gt;&lt;/script&gt;
</code></pre><p>然而，这样每个文件就是一个HTTP请求（我们都知道，浏览器的并行下载数是有限的）。</p>
<pre><code>&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
</code></pre><p>所以，合并你的JS文件。文件数量的减少就会带来请求数量的减少和更快的页面加载速度。</p>
<p>想要两全其美？通过构建工具自动化这个过程吧。</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="14-总是使用最新版本jquery"><a href="#14-总是使用最新版本jquery" class="headerlink" title="14. 总是使用最新版本jquery"></a>14. 总是使用最新版本jquery</h3><p>jQuery的核心团队通过改进代码的可读性、加入新的函数和优化现有的算法，不停地改进着这个库。</p>
<p>New is always better</p>
<h3 id="15-使用for，而不是each"><a href="#15-使用for，而不是each" class="headerlink" title="15. 使用for，而不是each"></a>15. 使用for，而不是each</h3><p>原生Javascript中的函数执行几乎总是要比jQuery快一些。正因为如此，请使用Javascript的<code>for</code>循环，不要使用<code>jQuery.each</code>方法。</p>
<p>但是请注意，虽然<code>for in</code>是原生的，可是在许多情况下，它的性能要比<code>jQuery.each</code>差一些。</p>
<p>在<code>for</code>循环迭代时，请记得缓存集合的长度。</p>
<pre><code>for ( var i = 0, len = a.length; i &lt; len; i++ ) {
    e = a[i];
}
</code></pre><h3 id="16-不要使用jquery…"><a href="#16-不要使用jquery…" class="headerlink" title="16. 不要使用jquery…"></a>16. 不要使用jquery…</h3><p>…除非它是必需的。 :)</p>
<p>有时JavaScript要比jQuery简单一些。</p>
<p>使用<code>attr()</code>方法来查询ID：</p>
<pre><code>$(&apos;a&apos;).on(&apos;click&apos;, function() {
  console.log( $(this).attr(&apos;id&apos;) );
});
</code></pre><p>如果你能通过<code>this</code>的本身属性获得，还需要上面的方法吗？</p>
<pre><code>$(&apos;a&apos;).on(&apos;click&apos;, function() {
  console.log( this.id );
});
</code></pre><p>而且这样还更快。</p>
<p>##Images</p>
<h3 id="17-使用css-sprites"><a href="#17-使用css-sprites" class="headerlink" title="17. 使用css sprites"></a>17. 使用css sprites</h3><p>这个技术就是将各种图片整合到一个文件中去。然后通过CSS去定位它们。</p>
<pre><code>.icon-foo {
  background-image: url(&apos;mySprite.png&apos;);
  background-position: -10px -10px;
}

.icon-bar {
  background-image: url(&apos;mySprite.png&apos;);
  background-position: -5px -5px;
}
</code></pre><p>这么做的结果就是，减少了HTTP请求数，避免延迟页面上的其他资源。</p>
<p>在使用sprite时，应当避免在每个图片之间的空隙过大。这个虽然不会影响到文件的大小，但是会影响到内存的消耗。</p>
<h3 id="18-data-uri"><a href="#18-data-uri" class="headerlink" title="18. data uri"></a>18. data uri</h3><p>这种技术是CSS Sprites的替代方法。</p>
<p>Data-URI是指使用图片的数据代替通常使用的图片URI，在下面的例子中，我们就使用它减少了HTTP请求数。</p>
<p>使用前:</p>
<pre><code>.icon-foo {
  background-image: url(&apos;foo.png&apos;);
}
</code></pre><p>使用后:</p>
<pre><code>.icon-foo {
  background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII%3D&apos;);
}
</code></pre><p>所有的现代浏览器和IE8及以上版本的IE都支持这个方法，图片需要使用base64方法编码。</p>
<p>这种技术和CSS Sprites技术都是可以使用构建工具得到的。使用构建工具的好处是不用手工去进行图片的拼合替换，在开发时使用单独的文件就可以。</p>
<p>然而坏处是，随着你的HTML/CSS文件的增大增多，你必须考虑你可能会有一个非常大的图片。如果你在HTTP请求中没有使用gzip技术压缩你的HTML/CSS，那么不推荐使用这种方法，因为减少HTTP请求数得到的大文件对于速度来说可能带来相反的结果。</p>
<h3 id="19-不要在-标签中调整图像"><a href="#19-不要在-标签中调整图像" class="headerlink" title="19. 不要在  标签中调整图像"></a>19. 不要在 <img> 标签中调整图像</h3><p>总是在<code>img</code>标签中设置<code>width</code>和<code>height</code>属性。这样可以防止渲染过程中的重绘和重排。</p>
<pre><code>&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;logo.jpg&quot; alt=&quot;Logo&quot;&gt;
</code></pre><p>知道这个之后，一个开发者将一个700x700px的图像设置为50x50px来显示。</p>
<p>但是这个开发者不知道的是，大量的没有用的数据也发送到了客户端。</p>
<p>所以请记住：你可以在标签中定义一个图片的宽高，但不意味着你应该通过这么做来(等比)缩放大图。</p>
<h3 id="20-优化你的图片"><a href="#20-优化你的图片" class="headerlink" title="20. 优化你的图片"></a>20. 优化你的图片</h3><p>一种方式是无损压缩</p>
<p>另一种优化图片的方式是，以图片质量为代价进行压缩。我们称之为有损压缩。举例来说，当你到处一个JPEG图片时，你可以选择导出的图片质量（从0到100）。考虑到性能，总是选择可接受范围内的最低值。在PNG图片中，另一个常见的有损技术是减少颜色数量，或者将PNG-24格式转换为PNG-8格式。</p>
<p>为了提升用户的体验，你还应该将你的JPEG文件转换为渐进式的。现在大多数的浏览器都支持渐进式JPEG文件，并且这种格式的文件创建简单，没有明显的性能损失问题。</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="21-诊断工具：你最好的朋友"><a href="#21-诊断工具：你最好的朋友" class="headerlink" title="21. 诊断工具：你最好的朋友"></a>21. 诊断工具：你最好的朋友</h3><p>YSlow和 PageSpeed等<br>都可以对你的网站的性能进行分析，并且给出分析报告，还可以对潜在的问题给出建议。</p>
<h3 id="22-没有银弹"><a href="#22-没有银弹" class="headerlink" title="22. 没有银弹"></a>22. 没有银弹</h3><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://developer.yahoo.com/performance/rules.html/" target="_blank" rel="external">雅虎军规Yahoo! Best Practices</a> </p>
<p><a href="https://developers.google.com/web/fundamentals/?hl=zh-cn" target="_blank" rel="external">developers.google.com</a> </p>
<p><a href="http://taitems.github.io/Front-End-Development-Guidelines/" target="_blank" rel="external">FrontEnd Development Guidelines</a> </p>
<p><a href="http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/" target="_blank" rel="external">Front-end performance for web designers and front-end developers</a> </p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-17-Article007.html"><span>jQuery源码与前端模块化</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-17-Article007.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-16T18:18:06.000Z">
          2016-06-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>任何库与框架设计的第一个要点就是决解命名空间与变量污染的问题。本文分析jQuery的解决方案，并引申前端模块化的问题</p>
<h3 id="1-jQuery解决方案"><a href="#1-jQuery解决方案" class="headerlink" title="1 jQuery解决方案"></a>1 jQuery解决方案</h3><p>jQuery代码比较长，把它的实现简化就是如下代码：</p>
<pre><code>(function(window, factory) {
    factory(window);
}(this, function() {
    return function() {
       //jQuery的调用
    }
}))
</code></pre><p>这种方法有点复杂,上面的代码中嵌套了2个函数，而且把一个函数作为参数传递到另一个函数中并且执行.原理是利用了JavaScript函数作用域的特性，采用立即调用表达式的方法，达到一种自执行的目的。</p>
<p>下面这种是在很多库中的实现方法如下：</p>
<pre><code>(function(window, undefined) {
    var jQuery = function() {}
    // ...
    window.jQuery = window.$ = jQuery;
})(window);
</code></pre><p>上面代码中的两个点：</p>
<ol>
<li>window和undefined都是为了减少变量查找所经过的scope作用域</li>
<li>为什么要传递undefined? 因为Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。</li>
</ol>
<p>这种写法也就是一种模块模式，通过立即执行函数的运用，不会污染全局作用域，解决了命名冲突的问题。</p>
<h3 id="2-前端模块化"><a href="#2-前端模块化" class="headerlink" title="2 前端模块化"></a>2 前端模块化</h3><p>后端语言如Java，Python，都会import功能，方便管理不同的库。前端以前没有这样的功能（注：es6引入模块化），随着前端的繁荣，前端开发越来越复杂，管理这些前端文件和处理依赖也会是一个问题。</p>
<p>这里介绍一下Sea.js和RequireJs,吐槽最近面试问这个的好多。</p>
<p>相同：</p>
<p>RequireJS 和 Sea.js 都是模块加载器</p>
<p>不同：</p>
<ol>
<li>遵循的规范不同。RequireJS 遵循 AMD规范，Sea.js 遵循 CMD 规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。</li>
<li>依赖不同。</li>
</ol>
<p>RequireJS推荐写法</p>
<pre><code>define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) {//依赖必须一开始就写好
  a.doSomething();
  b.doSomething();
});
</code></pre><p>RequireJS异步加载模块，依赖前置，提前执行（待定）。</p>
<p>Seajs模块写法：</p>
<pre><code>define(function(require, exports, module) {
  var a = require(&quot;./a&quot;);
  a.doSomething();
  //省略..行
  var b = require(&quot;./b&quot;);// 依赖可以就近书写
  b.doSomething();
});
</code></pre><p>Seajs同步加载，依赖就近，延迟执行。</p>
<p>这些异同不重要，关键是要养成模块化开发的习惯</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><ol>
<li>全局变量是魔鬼，尽量少。</li>
<li>培养模块化开发的习惯。</li>
</ol>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-16-Article006.html"><span>javascript的数据类型</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-16-Article006.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-15T18:18:06.000Z">
          2016-06-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>javascript的数据类型在不同的地方会有不同的分类，这里介绍最为主流的。</p>
<p>即分为原始类型（primitive type  基本类型）和 引用类型（object type 对象类型）。</p>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。</p>
<p>Undefined 类型：</p>
<pre><code>一个没有被赋值的变量会有个默认值 undefined
</code></pre><p>Null 类型：</p>
<pre><code>Null 类型只有一个值： null
</code></pre><p>Boolean 类型：</p>
<pre><code>布尔表示一个逻辑实体，可以有两个值：true 和 false。
</code></pre><p>Number 类型：</p>
<pre><code>JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。
</code></pre><p>String 类型：</p>
<pre><code>JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。 JavaScript 字符串是不可更改的。
</code></pre><p>注1：Symbol ( 在 ECMAScript 6 中新添加的类型)<br>注2：原始类型都是<strong>不可变的</strong>（值本身无法被改变）。存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。例如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>注1：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>
<p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p>
<pre><code>1. typeof
2. instanceof
3. Object.prototype.toString
</code></pre><p>#####typeof操作符：</p>
<pre><code>typeof undefined     //  &quot;undefined&quot;
typeof null          //  &quot;object&quot;    这是历史原因遗留错误，但从技术上来说，它仍然是原始值。
typeof ture/false    //  &quot;boolean&quot;
typeof 123           //  &quot;number&quot;
typeof &quot;&quot;            //  &quot;string&quot;
typeof {}            //  &quot;object&quot;
typeof function(){}  //  &quot;function&quot;
</code></pre><p>为了检测一个对象的类型，强烈推荐使用 Object.prototype.toString 方法； 因为这是唯一一个可依赖的方式。<br>在实际应用中，typeof就是检测一个元素是否为undefined。做一些原始类型的判断。</p>
<p>#####instanceof 操作符：</p>
<p>instanceof 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 typeof 操作符 一样用处不大。</p>
<p>instanceof 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 typeof 操作符一样，任何其它的用法都应该是避免的。</p>
<p>#####类型转换：</p>
<p>转换为字符串</p>
<pre><code>&apos;&apos; + 10 === &apos;10&apos;; // true
</code></pre><p>转换为数字</p>
<pre><code>+&apos;010&apos; === 10
Number(&apos;010&apos;) === 10
parseInt(&apos;010&apos;, 10) === 10  // 用来转换为整数

+&apos;010.2&apos; === 10.2
Number(&apos;010.2&apos;) === 10.2
parseInt(&apos;010.2&apos;, 10) === 10
</code></pre><p>转换为布尔型</p>
<pre><code>!!&apos;foo&apos;;   // true
!!&apos;&apos;;      // false
!!&apos;0&apos;;     // true
!!&apos;1&apos;;     // true
!!&apos;-1&apos;     // true
!!{};      // true
!!true;    // true
</code></pre>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-15-Article005.html"><span>CSS定位体系概述</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-15-Article005.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-14T18:18:06.000Z">
          2016-06-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>CSS盒模型(Box Model)规定了对元素内容，内边距，边框，外边距的处理方式，也就是盒子内部的规范。那盒模型出现的位置，就牵涉到CSS中的定位体系，这里做一个系统的介绍。理论性的东西较多</p>
<h3 id="三种定位方案"><a href="#三种定位方案" class="headerlink" title="三种定位方案"></a>三种定位方案</h3><p>CSS 2.1 中，会根据三种定位方案来摆放盒模型：</p>
<ol>
<li>常规流( Normal flow )。在 CSS2.1中，常规流包括块框的块格式化， 行内框的行内格式化，块框或行内框的相对定位(relative)。</li>
<li>浮动(Floats)。在浮动模型中，一个框( box )<strong>首先根据常规流布局</strong>，再将它<strong>从流中取出并尽可能地向左或向右偏移</strong>。内容可以沿浮动区的侧面排列。 因为它首先要根据常规布局后才偏移，所以效率较常规流低。</li>
<li>绝对定位。在绝对定位模型中，一个框会从常规流中<strong>完全脱离</strong>出来（它对后续的兄弟没有影响），并相对其<strong>包含块</strong>来指定其位置。</li>
</ol>
<h3 id="正常排版Normal-flow"><a href="#正常排版Normal-flow" class="headerlink" title="正常排版Normal flow"></a>正常排版Normal flow</h3><p>框在正常排版中必然属于一个格式化上下文，要么是块格式化上下文，要么是行格式化上下文。</p>
<p>Block在块格式化上下文中，框会从包含块的顶部开始，一个接一个地，垂直向下地摆放(独占一行)。</p>
<p>Inline在行格式化上下文中，框会从包含块的顶部开始，一个接一个地水平摆放。</p>
<p>相对定位 Relative positioning</p>
<p>当一个框按照正常排版或浮动来摆放好之后，它就可能相对当时的位置再有所偏移，这被称作<strong>相对定位</strong>。</p>
<h3 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动 Floats"></a>浮动 Floats</h3><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p>
<p>浮动常用来制作水平导航，或者实现多列布局。</p>
<p>clearfix<br>但是，由于浮动特性，容器如果没有明确设定高度，会依照普通流内元素高度设置，这样就会导致脱离普通流的浮动元素溢出容器，影响其后元素布局。</p>
<ol>
<li>采用一个HTML标签，以及css的clear属性，来手工清理浮动</li>
<li>采用伪类:after，动态建立一个块元素，设定 clear 属性，清理之前的浮动元素（推荐）</li>
<li>采用CSS overflow 非 visible 值(overflow:auto/overflow:hidden)设定使父容器包含浮动元素（BFC）</li>
<li>将父元素同样浮动，就可以包含浮动内容</li>
<li>在 IE 6/7 的标准文档模式中设置 “width/height/zoom” 等样式来自动清理浮动（hasLayout ）</li>
</ol>
<p>写了这么多方法其实他们清除浮动的原理</p>
<ol>
<li>clear</li>
<li>触发BFC或hasLayout</li>
</ol>
<h3 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位 Absolute positioning"></a>绝对定位 Absolute positioning</h3><p>在绝对定位模型中，一个框基于它的包含块而显式地偏移。它完全从正常排版中脱离(对后继的兄弟没有影响)。</p>
<p>包含块containing block<br>判定总流程图如下：</p>
<p><img src="/img/pic-005-1.png" alt=""></p>
<p>简单来说就是非static的祖先元素</p>
<h3 id="影响框的生成和布局的三个属性——‘display’，’position’和’float’——间的相互关系如下"><a href="#影响框的生成和布局的三个属性——‘display’，’position’和’float’——间的相互关系如下" class="headerlink" title="影响框的生成和布局的三个属性——‘display’，’position’和’float’——间的相互关系如下:"></a>影响框的生成和布局的三个属性——‘display’，’position’和’float’——间的相互关系如下:</h3><ol>
<li>如果’display’值为’none’，那么’position’和’float’无效，元素不生成框。</li>
<li>否则，如果’position’值为’absolute’或者’fixed’，框绝对地定位’float’计算的值为’none’，并且 display根据下面的表格进行设定。框的位置由’top’, ‘right’, ‘bottom’和’left’属性和包含块决定。</li>
<li>否则，如果’float’的值不是’none’，该框是浮动的，且’display’值根据下面的表格进行设定。</li>
<li>否则，如果元素是根元素，’display’值根据下面的表格进行设定，除了其在CSS2.1里面没有定义是否指定值’list-item’对应计算值’block’或者’list-item’。</li>
<li>否则，’display’ 的计算值为指定的值。</li>
</ol>
<p>流程图如下：</p>
<p><img src="/img/pic-005-2.png" alt=""></p>
<table class="table"><br>      <tbody><tr><br>        <th>设定值</th><br>        <th>计算值</th><br>      </tr><br>      <tr><br>        <td>inline-table </td><br>        <td>table</td><br>      </tr><br>      <tr><br>        <td>inline, run-in, table-row-group, table-column, table-column-group, table-header-group, <br><br>          table-footer-group, table-row, table-cell, table-caption, inline-block </td><br>        <td>block</td><br>      </tr><br>      <tr><br>        <td>其他</td><br>        <td>同设定值</td><br>      </tr><br>    </tbody><br></table>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.w3.org/html/ig/zh/wiki/CSS2/visuren" target="_blank" rel="external">http://www.w3.org/html/ig/zh/wiki/CSS2/visuren</a></p>
<p><a href="http://www.w3help.org/zh-cn/kb/009/" target="_blank" rel="external">http://www.w3help.org/zh-cn/kb/009/</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-14-Article004.html"><span>DOM 小结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-14-Article004.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-13T18:18:06.000Z">
          2016-06-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>DOM是在学习前端过程中经常见到的一个名词，也是前端工程师必须了解的一个重要技能分支，这里对DOM作一个学习总结。</p>
<p>###什么是 DOM?</p>
<p>DOM 是 Document Object Model（文档对象模型）的缩写。</p>
<p>官方的定义是：</p>
<blockquote>
<p>“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p>
</blockquote>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
<p>前端重点关注的是HTML DOM，HTML DOM 定义了所有 HTML 元素的<strong>对象</strong>和<strong>属性</strong>，以及访问它们的<strong>方法</strong>。从本质上说，它将web 页面和脚本或编程语言连接起来了。</p>
<p>换言之，HTML DOM 是关于如何<strong>获取、修改、添加或删除 HTML 元素的标准</strong>。（增删改查）</p>
<p>尽管DOM 通常会使用 JavaScript 来访问， 但它并不是 js 的一部分，它也可以被其他语言使用。</p>
<p>###DOM 节点 与 DOM 树</p>
<p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是<strong>节点</strong>：</p>
<ul>
<li>整个文档是一个文档节点</li>
<li>每个 HTML 元素是元素节点</li>
<li>HTML 元素内的文本是文本节点</li>
<li>每个 HTML 属性是属性节点</li>
<li>注释是注释节点</li>
</ul>
<p>HTML DOM 将 HTML 文档视作树结构。这种结构被称为<strong>节点树</strong>：</p>
<p><img src="/img/pic-004-1.gif" alt=""></p>
<h3 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h3><p>可通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问。<strong>所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。</strong>方法是您能够执行的动作（比如添加或修改元素）。属性是您能够获取或设置的值（比如节点的名称或内容）。</p>
<div><br><h2>一些 DOM 对象方法</h2><br><br><p>这里提供一些您将在本教程中学到的常用方法：</p><br><br><br><table class="table"><br><tbody><tr><br><th>方法</th><br><th>描述</th><br></tr><br><br><tr><br><td>getElementById()</td><br><td>返回带有指定 ID 的元素。</td><br></tr><br><br><tr><br><td>getElementsByTagName()</td><br><td>返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。</td><br></tr><br><br><tr><br><td>getElementsByClassName()</td><br><td>返回包含带有指定类名的所有元素的节点列表。Internet Explorer 5,6,7,8 中无效。</td><br></tr><br><br><tr><br><td>appendChild()</td><br><td>把新的子节点添加到指定节点。</td><br></tr><br><br><tr><br><td>removeChild()</td><br><td>删除子节点。</td><br></tr><br><br><tr><br><td>replaceChild()</td><br><td>替换子节点。</td><br></tr><br><br><tr><br><td>insertBefore()</td><br><td>在指定的子节点前面插入新的子节点。</td><br></tr><br><br><tr><br><td>createAttribute()</td><br><td>创建属性节点。</td><br></tr><br><br><tr><br><td>createElement()</td><br><td>创建元素节点。</td><br></tr><br><br><tr><br><td>createTextNode()</td><br><td>创建文本节点。</td><br></tr><br><br><tr><br><td>getAttribute()</td><br><td>返回指定的属性值。</td><br></tr><br><br><tr><br><td>setAttribute()</td><br><td>把指定属性设置或修改为指定的值。</td><br></tr><br></tbody></table><br></div>

<p>一些常用的 HTML DOM 属性：</p>
<ul>
<li>innerHTML - 节点（元素）的文本值</li>
<li>parentNode - 节点（元素）的父节点</li>
<li>childNodes - 节点（元素）的子节点</li>
<li>attributes - 节点（元素）的属性节点</li>
</ul>
<p>tips：</p>
<ol>
<li>改变元素内容的最简单的方法是使用 <strong>innerHTML</strong> 属性</li>
<li>访问 HTML 样式通过 <strong>style</strong> 属性</li>
<li>如需向 HTML DOM 添加新元素，您首先必须创建(<strong>createElement</strong>)该元素，然后把它追加(<strong>appendChild或insertBefore</strong>)到已有的元素上</li>
<li>如需删除 HTML 元素，您必须清楚该元素的父元素<strong>removeChild</strong>。写法：child.parentNode.removeChild(child)</li>
<li>如需替换 HTML DOM 中的元素，请使用 replaceChild() 方法</li>
<li>注册事件例子：document.getElementById(“myBtn”).onclick=function(){…};</li>
<li>window.onload = function(){};</li>
<li>访问表单内容value</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model</a></p>
<p><a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank" rel="external">http://www.w3school.com.cn/htmldom/index.asp</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-13-Article003.html"><span>维吉尼亚密码</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-13-Article003.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-12T18:18:06.000Z">
          2016-06-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>维吉尼亚密码属于古典密码中的一种多表密码，是在单一恺撒密码的基础上扩展出多表密码，以其简单易用而著称，同时初学者通常难以破解，因而又曾被称为“不可破译的密码”。我这里利用javascript实现了维吉尼亚密码的加密和解密过程，并且运用频率统计，重合指数法在仅有密文而不知道密钥的情况下实现密码破解。</p>
<p>网站地址：<a href="http://atomcated.github.io/Vigenere/" target="_blank" rel="external">Vigenere</a></p>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>多表密码最早在1467年左右由莱昂·巴蒂斯塔·阿尔伯蒂提出，他使用了一个金属密码盘来切换密码表，只是这个系统只能做些有限的转换。后来1508年时，约翰尼斯·特里特米乌斯《隐写术》（Steganographia）中发明的<strong>表格法</strong>（tabula recta）成为了维吉尼亚密码的关键部分。然而当时此方法只能对密码表做一些简单的、可预测的切换。这一加密技术也称为特里特米乌斯密码。</p>
<p>这一方法真正出现是在吉奥万·巴蒂斯塔·贝拉索于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的算术》中。他以特里特米乌斯的表格法为基础，同时引入了<strong>密钥</strong>的概念。</p>
<p>布莱斯·德·维吉尼亚于1586年亨利三世时期发明了更为简单却又更有效的自动密钥密码（autokey cipher）。之后，19世纪时贝拉索的方法被误认为是由维吉尼亚首先发明的。大卫·卡恩在《破译者（The Codebreakers）》中对此表示遗憾，他写道“历史忽略了这一重要贡献，将其归功于维吉尼亚，虽然他对此并不知道”。</p>
<p>由于破译的难度很高，维吉尼亚密码也因此获得了很高的声望。知名作家、数学家查尔斯·路特维奇·道奇森（笔名路易斯·卡罗）在其1868年所编、收于一儿童杂志的《字母表密码（The Alphabet Cipher）》中称其是不可破译的。1917年，《科学美国人》将维吉尼亚密码称为“无法被转化的”。然而，维吉尼亚密码却配不上这样的称号。查尔斯·巴贝奇完成了破译的工作，但他没有将此发表。之后，弗里德里希·卡西斯基（Friedrich Kasiski）于19世纪完全破解并发表了他的方法。甚至在此之前，一些资深密码分析家在16世纪就能偶尔将其破解。</p>
<h3 id="保密系统模型"><a href="#保密系统模型" class="headerlink" title="保密系统模型"></a>保密系统模型</h3><p><img src="/img/pic-003-1.jpg" alt=""></p>
<p>一个密码系统通常有五部分组成：</p>
<ol>
<li>明文（Plaintext）</li>
<li>密文(Ciphertext)</li>
<li>加密（Encrypt ）</li>
<li>解密（Decrypt）</li>
<li>密钥（Key ）</li>
</ol>
<p>柯克霍夫斯（Kerckhoffs）原则：</p>
<blockquote>
<p>即使密码系统中的算法为密码分析者所知，也难以从截获的密文推导出明文或密钥。也就是说，密码体制的安全性仅应依赖于对密钥的保密，而不应依赖于对算法的保密。只有在假设攻击者对密码算法有充分的研究，并且拥有足够的计算资源的情况下仍然安全的密码才是安全的密码系统。一句话： “一切秘密寓于密钥之中”.</p>
</blockquote>
<p>###密码描述</p>
<p>在一个恺撒密码中，字母表中的每一字母都会作一定的偏移，例如偏移量为3时，A就转换为了D、B转换为了E……。而维吉尼亚密码则是由一些偏移量不同的恺撒密码组成。</p>
<p>设明文（Plaintext）</p>
<pre><code>P = p1p2...pn
</code></pre><p>密钥（Key ）</p>
<pre><code>K = k1k2...kn  //当密钥长度小于明文，密钥周期使用
</code></pre><p>例如，假设明文为：ATTACKATDAWN</p>
<p>选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：LEMONLEMONLE</p>
<p>可以得到：</p>
<pre><code>明文：ATTACKATDAWN
密钥：LEMONLEMONLE
密文：LXFOPVEFRNHR

加密公式：Ci = ( Pi + Ki ) mod 26
解密公式：Pi = ( Ci - Ki ) mod 26
</code></pre><p>###密码破译</p>
<p>这里简单表述在不知道密钥时的破解过程，具体实现在js源码中.</p>
<p>在多表古典密码分析中，首先要确定密钥的长度，也就是要首先确定所使用的加密表的个数，然后在分析确定具体的密钥。</p>
<ol>
<li>确定密钥长度。常用方法有<strong>Kasiski测试法</strong>和<strong>重合指数法</strong>。</li>
</ol>
<p>重合指数Ic是William F. Friedman于1920年发明的<br><img src="/img/pic-003-2.jpg" alt=""><br>英文字母A,B,C,…Z的期望概率可以从统计数据中知道，于是我们有</p>
<pre><code>Ic(x) ≈ ∑ pi^2  = 0.065
</code></pre><p>而对于随机的英文字母</p>
<pre><code>Ic ≈ 26 * （1/26)^2  = 0.038
</code></pre><p>0.065和0.038相差较远，所以我们可以确定密钥长度。将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。</p>
<ol>
<li>确定key</li>
</ol>
<p></p><p>英语中的字母频率如下：</p><p></p>
<table><br><tr><br><th>字母</th><br><th colspan="2">英语中出现的频率</th><br></tr><br><tr><br><td style="text-align:center;"><b>a</b></td><br><td align="right">8.167%</td><br><td align="left"><span style="display:none;">8.167</span><br><div style="width:163.34px;height:2ex;background:#aaa;background:blue">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>b</b></td><br><td align="right">1.492%</td><br><td align="left"><span style="display:none;">1.492</span><br><div style="width:29.84px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>c</b></td><br><td align="right">2.782%</td><br><td align="left"><span style="display:none;">2.782</span><br><div style="width:55.64px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>d</b></td><br><td align="right">4.253%</td><br><td align="left"><span style="display:none;">4.253</span><br><div style="width:85.06px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>e</b></td><br><td align="right">12.702%</td><br><td align="left"><span style="display:none;">12.702</span><br><div style="width:254.04px;height:2ex;background:#aaa;background:blue">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>f</b></td><br><td align="right">2.228%</td><br><td align="left"><span style="display:none;">2.228</span><br><div style="width:44.56px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>g</b></td><br><td align="right">2.015%</td><br><td align="left"><span style="display:none;">2.015</span><br><div style="width:40.3px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>h</b></td><br><td align="right">6.094%</td><br><td align="left"><span style="display:none;">6.094</span><br><div style="width:121.88px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>i</b></td><br><td align="right">6.966%</td><br><td align="left"><span style="display:none;">6.966</span><br><div style="width:139.32px;height:2ex;background:#aaa;background:blue">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>j</b></td><br><td align="right">0.153%</td><br><td align="left"><span style="display:none;">0.153</span><br><div style="width:3.06px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>k</b></td><br><td align="right">0.772%</td><br><td align="left"><span style="display:none;">0.772</span><br><div style="width:15.44px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>l</b></td><br><td align="right">4.025%</td><br><td align="left"><span style="display:none;">4.025</span><br><div style="width:80.5px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>m</b></td><br><td align="right">2.406%</td><br><td align="left"><span style="display:none;">2.406</span><br><div style="width:48.12px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>n</b></td><br><td align="right">6.749%</td><br><td align="left"><span style="display:none;">6.749</span><br><div style="width:134.98px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>o</b></td><br><td align="right">7.507%</td><br><td align="left"><span style="display:none;">7.507</span><br><div style="width:150.14px;height:2ex;background:#aaa;background:blue">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>p</b></td><br><td align="right">1.929%</td><br><td align="left"><span style="display:none;">1.929</span><br><div style="width:38.58px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>q</b></td><br><td align="right">0.095%</td><br><td align="left"><span style="display:none;">0.095</span><br><div style="width:1.9px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>r</b></td><br><td align="right">5.987%</td><br><td align="left"><span style="display:none;">5.987</span><br><div style="width:119.74px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>s</b></td><br><td align="right">6.327%</td><br><td align="left"><span style="display:none;">6.327</span><br><div style="width:126.54px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>t</b></td><br><td align="right">9.056%</td><br><td align="left"><span style="display:none;">9.056</span><br><div style="width:181.12px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>u</b></td><br><td align="right">2.758%</td><br><td align="left"><span style="display:none;">2.758</span><br><div style="width:55.16px;height:2ex;background:#aaa;background:blue">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>v</b></td><br><td align="right">0.978%</td><br><td align="left"><span style="display:none;">0.978</span><br><div style="width:19.56px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>w</b></td><br><td align="right">2.360%</td><br><td align="left"><span style="display:none;">2.36</span><br><div style="width:47.2px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>x</b></td><br><td align="right">0.150%</td><br><td align="left"><span style="display:none;">0.15</span><br><div style="width:3px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>y</b></td><br><td align="right">1.974%</td><br><td align="left"><span style="display:none;">1.974</span><br><div style="width:39.48px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br><tr><br><td style="text-align:center;"><b>z</b></td><br><td align="right">0.074%</td><br><td align="left"><span style="display:none;">0.074</span><br><div style="width:1.48px;height:2ex;background:#aaa;">&#160;</div><br></td><br></tr><br></table>

<p><strong>对通过同一个key加密的等间隔的密文进行字母分布统计，key应该是能与上图形成最匹配的相对位移，穷举26个可能的密钥，很容易得到key各个位的值</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher" target="_blank" rel="external">https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher</a></p>
<p><a href="http://smurfoncrack.com/pygenere/" target="_blank" rel="external">http://smurfoncrack.com/pygenere/</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-12-Article002.html"><span>百度IFE介绍</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-12-Article002.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-11T18:18:06.000Z">
          2016-06-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>百度Web前端技术学院是一个由百度EFE团队、百度人力资源部校园招聘组联合出品的、面向在校大学生的前端培训组织，我们希望能够借助百度大量优秀的前端工程师以及丰富的前端知识积累，帮助大学生们更加高效、系统地学习Web前端技术。</p>
<p>我在前几个月跟了这个学习班，现在回忆并把记录心得到这个博客，算是纪念。</p>
<h3 id="培训方式介绍"><a href="#培训方式介绍" class="headerlink" title="培训方式介绍"></a>培训方式介绍</h3><p>现在校同学在学习前端技术时最大的困扰有以下三个方面：</p>
<ul>
<li>前端技术点非常多，无从下手，总感觉东一榔头、西一棒槌，缺乏系统性</li>
<li>缺乏有效的实践，尤其在没有实习机会时，很难有效、主动地进行代码实践</li>
<li>缺乏指导</li>
</ul>
<p>基于这三个因素，我们把教学的方法定为：提供一系列由浅入深，由点到面的编码挑战任务，并把前端所需要的各种技术知识点通过实践来让同学们学会。同时，我们会安排许多优秀的百度前端工程师，帮助进行代码的Review，进行一对一的指导。</p>
<h3 id="报名方法"><a href="#报名方法" class="headerlink" title="报名方法"></a>报名方法</h3><ol>
<li>学习github使用方法；</li>
<li>fork本项目；</li>
<li>在报名目录下，比如您要报第一期的初级班，就到目录apply/2015001/junior/，按照apply_example.md模板文件，建立以您github账号命名的报名文件（如您的github账号为diysimon，则命名为diysimon.md，初始内容与apply_example.md一样）；中级班到apply/期数/intermediate，高级班到apply/期数/advanced；</li>
<li>按照md文件内容中的提示完成该文件内容的补充；</li>
<li>pull request你的md文件。</li>
</ol>
<h3 id="任务提交方式"><a href="#任务提交方式" class="headerlink" title="任务提交方式"></a>任务提交方式</h3><p>任务提交方式会在每个任务说明中描述。大体方式为在专门开设的任务提交issue回复你的任务地址。<br>整体学习周期预计为 2个月。如果中途因为个人原因退出，可以随时与我们沟通。</p>
<h3 id="毕业面谈及评价"><a href="#毕业面谈及评价" class="headerlink" title="毕业面谈及评价"></a>毕业面谈及评价</h3><p>当所有任务完成后，我们会安排工程师对您进行一次类似于技术面试的面谈或电话面谈，根据面谈结论，我们会给予一份带有对您在IFE学习的评价的毕业证书。对于所有获得毕业证书的同学，我们会在征得您同意的情况下，在我们网站中放上您的评价信息，方便您找工作时，其他企业对这些信息的确认。</p>
<p>同时，我们针对每期最优秀的一些学员，会给与最佳学员的荣誉称号，以及进入百度实习甚至校招的机会。</p>
<h3 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h3><p><a href="https://github.com/baidu-ife/ife" target="_blank" rel="external">github</a></p>
<p><a href="http://weibo.com/baiduife" target="_blank" rel="external">IFE微博</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-11-Article001.html"><span>Markdown 语法指南</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-11-Article001.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-10T18:18:06.000Z">
          2016-06-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>jekyll用 Markdown (或 Textile)、Liquid、HTML &amp; CSS 就可以构建可部署的静态网站。</p>
<p>下面记录一些常用的语法：</p>
<p>git用法</p>
<pre><code>git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master

git add .&amp;&amp;git commit -m &quot;Initial commit&quot;&amp;&amp;git push -u origin master
</code></pre><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>文章内容较多时，可以用标题分段：</p>
<pre><code>标题1
======
标题2
-----
## 大标题 ##
### 小标题 ###
</code></pre><h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h3><pre><code>*斜体文本*    _斜体文本_
**粗体文本**    __粗体文本__
***粗斜体文本***    ___粗斜体文本___
</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><pre><code>文字链接 [百度](https://www.baidu.com)
网址链接 &lt;https://www.baidu.com&gt;
</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>跟链接的方法区别在于前面加了个感叹号 !</p>
<pre><code>![图片名称](http://图片网址)
</code></pre><p>也可以使用 HTML 的图片语法来自定义图片的宽高大小</p>
<pre><code>&lt;img src=&quot;htt://example.com/sample.png&quot; width=&quot;400&quot; height=&quot;100&quot;&gt;
</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre><code>Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。
要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以
</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>普通无序列表</p>
<pre><code>- 列表文本前使用 [减号+空格]
+ 列表文本前使用 [加号+空格]
* 列表文本前使用 [星号+空格]
</code></pre><p>普通有序列表</p>
<pre><code>1. 列表前使用 [数字+空格]
2. 我们会自动帮你添加数字
7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3
</code></pre><p>列表嵌套</p>
<pre><code>1. 列出所有元素：
    - 无序列表元素 A
        1. 元素 A 的有序子列表
    - 前面加四个空格
2. 列表里的多段换行：
    前面必须加四个空格，
    这样换行，整体的格式不会乱
3. 列表里引用：

    &gt; 前面空一行
    &gt; 仍然需要在 &gt;  前面加四个空格

4. 列表里代码段：

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面四个空格，之后按代码语法 ``` 书写</span><br></pre></td></tr></table></figure>

        或者直接空八个，引入代码块
</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>普通引用</p>
<pre><code>&gt; 引用文本前使用 [大于号+空格]
&gt; 折行可以不加，新起一行都要加上哦
</code></pre><p>引用里嵌套引用</p>
<pre><code>&gt; 最外层引用
&gt; &gt; 多一个 &gt; 嵌套一层引用
&gt; &gt; &gt; 可以嵌套很多层
</code></pre><p>引用里嵌套列表</p>
<pre><code>&gt; - 这是引用里嵌套的一个列表
&gt; - 还可以有子列表
&gt;     * 子列表需要从 - 之后延后四个空格开始
</code></pre><p>引用里嵌套代码块</p>
<pre><code>&gt;     同样的，在前面加四个空格形成代码块
&gt;
&gt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 或者使用 ``` 形成代码块</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</code></pre><p>分隔符</p>
<pre><code>---

***
</code></pre>
      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016-06-10-hello-world.html"><span>Hello World</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016-06-10-hello-world.html" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-09T18:18:06.000Z">
          2016-06-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一个平平常常的日子，细蒙蒙的雨丝夹着一星半点的雪花，正纷纷淋淋地向大地飘洒着。时令已快到惊蛰，雪当然再不会存留，往往还没等落地，就已经消失得无踪无影了。黄土高原严寒而漫长的冬天看来就要过去，但那真正温暖的春天还远远地没有到来。</p>
<pre><code>$(document).ready(function () {
    alert(&apos;hello world&apos;);
});
</code></pre><h1 id="这是-H1"><a href="#这是-H1" class="headerlink" title="这是 H1"></a>这是 H1</h1><h2 id="这是-H2"><a href="#这是-H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h6 id="这是-H6"><a href="#这是-H6" class="headerlink" title="这是 H6"></a>这是 H6</h6><p>这是区块引用</p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<p>无序列表</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>分隔线</p>
<hr>
<p>有序列表</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 John Doe
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>